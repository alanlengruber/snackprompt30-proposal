Perfeito. Para facilitar o **Discovery T√©cnico**, vou estruturar estes documentos n√£o apenas como uma "ordem de servi√ßo", mas como **Propostas de Design**.

O objetivo √© apresentar a estrutura proposta e listar os **"Pontos de Decis√£o"** onde o time t√©cnico precisa opinar ou validar. Isso engaja a equipe e previne problemas futuros.

Aqui est√£o os Documentos 4 e 5, formatados para reuni√µes de alinhamento.

---

# üìÑ Documento 4: Modelagem de Dados & Contratos de API (Proposta para Discovery)

**Objetivo desta Sess√£o:** Definir como vamos salvar os Agentes, como vamos cobrar (Cr√©ditos) e como o Frontend vai conversar com o Backend (Streaming).

---

### 1. Modelagem de Dados (Postgres - Gerenciado pelo Go)

Precisamos expandir o schema atual para suportar o Marketplace e a Economia de Cr√©ditos.

#### A. Entidade: Agentes (`agents`)
*O "Pacote" que o usu√°rio cria e vende.*

| Campo | Tipo | Descri√ß√£o / Nota para Discuss√£o |
| :--- | :--- | :--- |
| `id` | UUID | PK |
| `author_id` | UUID | FK para `users`. |
| `title` | String | Nome p√∫blico do agente. |
| `description` | Text | Texto de marketing para o Marketplace. |
| `system_prompt` | Text (Encrypted) | **Cr√≠tico:** O "c√©rebro". Deve ser encriptado em repouso? |
| `model_config` | JSONB | `{ "provider": "openai", "model": "gpt-4o", "temperature": 0.7 }` |
| `visibility` | Enum | `private`, `public_free`, `marketplace_paid`. |
| `price_per_msg` | Int | Custo em Cr√©ditos (se for pago). |
| `is_blackbox` | Boolean | Se `true`, o comprador n√£o v√™ o prompt/tabelas associadas. |

#### B. Entidade: Links de Conhecimento (`agent_knowledge_links`)
*A cola entre o Agente e as Tabelas existentes.*

| Campo | Tipo | Descri√ß√£o |
| :--- | :--- | :--- |
| `agent_id` | UUID | FK |
| `table_id` | String | FK para sua tabela `snack_tables` atual. |
| `type` | Enum | `static` (conhecimento fixo do criador) ou `dynamic` (slot para o usu√°rio preencher). |

#### C. Entidade: Economia (`user_credits` & `transactions`)
*O sistema banc√°rio da plataforma.*

*   **Tabela `wallets`:** `user_id` | `balance` (Atomic Integer para evitar race conditions).
*   **Tabela `transactions`:** Log imut√°vel de cada consumo (`agent_usage`, `refill`, `payout`).

> **üî¥ Ponto de Discuss√£o com o Time:**
> *   Como vamos lidar com *Race Conditions* no saldo de cr√©ditos?
> *   *Sugest√£o:* Usar `SELECT FOR UPDATE` no Postgres ou transa√ß√µes at√¥micas no Redis antes de persistir no Postgres.

---

### 2. Contratos de API (JSON)

#### A. Endpoint de Chat (Streaming)
*Como o Chat parece "vivo".*

**Request:** `POST /api/chat/completions`
```json
{
  "agent_id": "uuid-do-agente",
  "messages": [
    { "role": "user", "content": "Analise este contrato." }
  ],
  "attached_user_tables": ["table_id_do_usuario_1"], // O RAG H√≠brido
  "stream": true
}
```

**Response (Server-Sent Events - SSE):**
O Python n√£o devolve um JSON √∫nico, mas um fluxo de eventos:

*   `event: citation` -> `{ "ref_id": 1, "source": "Tabela Jur√≠dica, C√©lula 2" }`
*   `event: token` -> `{ "text": "O" }`
*   `event: token` -> `{ "text": " contrato" }`
*   `event: token` -> `{ "text": " √©" }`
*   `event: done` -> `{ "total_tokens": 150, "credits_deducted": 2 }`

> **üî¥ Ponto de Discuss√£o com o Time:**
> *   O Frontend (Next.js) vai conectar direto no Python para lat√™ncia m√≠nima ou passaremos pelo Go?
> *   *Sugest√£o:* O Frontend chama o Python, mas envia um JWT assinado pelo Go para autentica√ß√£o.

---

# üìÑ Documento 5: A L√≥gica do "C√©rebro" - LangGraph (Proposta para Discovery)

**Objetivo desta Sess√£o:** Desenhar o fluxograma de como a IA "pensa" antes de responder. N√£o √© c√≥digo, √© l√≥gica.

---

### 1. O Estado do Grafo (State Schema)
O que a IA precisa "lembrar" durante o processamento de uma resposta?

```python
class AgentState(TypedDict):
    messages: list[BaseMessage]  # Hist√≥rico da conversa
    context_chunks: list[Document] # Peda√ßos de texto recuperados do Qdrant
    token_count: int             # Para o billing
    user_context: dict           # IDs das tabelas permitidas
```

### 2. O Fluxo de Decis√£o (Nodes & Edges)

Visualizem este fluxo para o nosso MVP:

1.  **START**
2.  **Node: Query Reformulation (Opcional)**
    *   *A√ß√£o:* A IA reescreve a pergunta do usu√°rio para ficar melhor para o banco vetorial.
    *   *Ex:* User: "E o pre√ßo?" -> IA: "Qual √© o pre√ßo do servi√ßo da Incentive Brands?"
3.  **Node: Multi-Hop Retrieval (O Cora√ß√£o do RAG)**
    *   *A√ß√£o:* Consulta o Qdrant.
    *   *Filtro Cr√≠tico:* `Filter( should: [ {table_id: KB_CRIADOR}, {table_id: KB_USUARIO} ] )`
    *   Isso √© o que permite o Agente Advogado ler a Lei (dele) e o Contrato (seu).
4.  **Node: Generate (LLM)**
    *   *A√ß√£o:* Recebe os chunks + System Prompt.
    *   *Regra de Ouro:* "Responda apenas com base no contexto. Adicione `[Ref: ID]` ao final das senten√ßas."
5.  **Node: Post-Processing**
    *   *A√ß√£o:* Formata os links de cita√ß√£o para o Frontend.
6.  **END**

> **üî¥ Ponto de Discuss√£o com o Time:**
> *   Vamos implementar "Self-Correction"? (Se a busca no Qdrant vier vazia, a IA tenta buscar de novo com outros termos ou avisa o usu√°rio?)
> *   *Sugest√£o:* Para o MVP, se n√£o achar nada, avisa que n√£o encontrou na base. Deixa a corre√ß√£o para a v2.

### 3. Integra√ß√£o com "Tools" (Futuro Pr√≥ximo)

Embora n√£o seja MVP, precisamos deixar o "slot" pronto no c√≥digo.

*   Se o Agente tiver a tool `search_web` habilitada, o LangGraph ter√° um **Conditional Edge**:
    *   *A IA decide:* "Preciso buscar no Google?" -> Vai para Node `WebSearch`.
    *   *A IA decide:* "J√° tenho a resposta na tabela?" -> Vai para Node `Generate`.

---

### Resumo das Decis√µes a Tomar na Reuni√£o (Checklist)

1.  [ ] **Modelagem:** Aprovamos a tabela de `transactions` para cr√©ditos? √â suficiente para auditoria?
2.  [ ] **Seguran√ßa:** Onde guardaremos a chave de criptografia dos System Prompts? (Vault, Env Var, AWS KMS?)
3.  [ ] **Streaming:** O time de Frontend est√° confort√°vel em consumir *Server-Sent Events*?
4.  [ ] **Python:** Vamos usar FastAPI ou Flask? (Recomenda√ß√£o forte: FastAPI por ser async nativo).

Estes documentos est√£o prontos para serem projetados na tela da sala de reuni√£o (ou compartilhados no Notion/Confluence) para guiar a discuss√£o t√©cnica.