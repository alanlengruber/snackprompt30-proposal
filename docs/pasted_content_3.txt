Voc√™ tem total raz√£o. A sincroniza√ß√£o √© a "espinha dorsal" de um sistema RAG. Se ela falhar, a IA responde com dados velhos ou alucina, e o usu√°rio perde a confian√ßa.

Como voc√™ busca uma arquitetura **robusta** e **profissional**, n√£o podemos depender de chamadas HTTP s√≠ncronas (que travam o usu√°rio esperando o embedding ser gerado) nem de cronjobs (que geram delay).

Precisamos de uma **Arquitetura Orientada a Eventos (Event-Driven Architecture)**.

Aqui est√° o **Documento 3**, focado exclusivamente na estrat√©gia de sincroniza√ß√£o e filas.

---

# üìÑ Documento 3: Estrat√©gia de Sincroniza√ß√£o de Dados (Data Sync)
## Projeto: Snack Prompt 2.0 ‚Äì Event Bus & Pipeline de Ingest√£o

### 1. O Desafio: Consist√™ncia vs. Lat√™ncia
Quando o usu√°rio clica em "Salvar" no Frontend:
1.  O dado deve ser persistido imediatamente no Postgres (Go) para seguran√ßa.
2.  O usu√°rio deve receber um "OK" instant√¢neo (UX fluida).
3.  O processo de Embedding (que √© pesado e lento) deve ocorrer em segundo plano.

Para isso, utilizaremos um **Message Broker** (Fila de Mensagens).

### 2. Tecnologia Escolhida: RabbitMQ (ou Redis Streams)

Para o n√≠vel de robustez que a Snack Prompt exige, recomendo o **RabbitMQ**.

*   **Por que RabbitMQ?** √â o padr√£o da ind√∫stria para sistemas distribu√≠dos. Ele garante a entrega da mensagem (Durability), permite re-tentativas autom√°ticas se o servi√ßo Python cair (Ack/Nack) e suporta roteamento complexo (Ex: filas priorit√°rias para usu√°rios Pagantes vs. Gratuitos).
*   *Alternativa Leve:* Se a infraestrutura precisar ser mais simples inicialmente, **Redis** (usando Pub/Sub ou Streams) funciona bem, mas o RabbitMQ oferece melhor visibilidade e gest√£o de falhas (Dead Letter Queues).

**Decis√£o para o Projeto:** Vamos arquitetar com **RabbitMQ**.

---

### 3. Fluxo de Dados Detalhado

O fluxo segue o padr√£o **Producer-Consumer**.

#### A. O Produtor (Backend Go)
O Go n√£o "pede" para o Python fazer algo. Ele apenas "avisa" que algo aconteceu.

1.  **A√ß√£o:** Usu√°rio edita uma c√©lula na Tabela e salva.
2.  **Persist√™ncia:** Go salva no Postgres (`COMMIT`).
3.  **Publica√ß√£o:** Imediatamente ap√≥s o commit, o Go publica uma mensagem no RabbitMQ na exchange `snack.events`.

**Estrutura da Mensagem (Payload JSON):**
```json
{
  "event_type": "ITEM_UPDATED", // ou ITEM_CREATED, ITEM_DELETED
  "timestamp": "2025-10-20T10:00:00Z",
  "data": {
    "snack_table_id": "sIHp8Lz61",
    "snack_column_id": "ovE1fCQZU",
    "snack_item_id": "WLsSS_LBf",
    "content_text": "Incentive Brands is a family-owned DFW partner...", 
    "metadata": {
       "author_id": "user_123",
       "is_public": false
    }
  }
}
```
*Nota:* Enviamos o conte√∫do dentro da mensagem para evitar que o Python tenha que consultar o Go novamente (reduzindo lat√™ncia e tr√°fego de rede).

#### B. A Fila (RabbitMQ)
O RabbitMQ recebe e enfileira. Aqui podemos criar **Filas Segregadas**:
*   `queue.ingestion.priority`: Para usu√°rios PRO (processamento instant√¢neo).
*   `queue.ingestion.standard`: Para usu√°rios Free (pode ter um leve atraso em hor√°rios de pico).

#### C. O Consumidor (AI Engine - Python/FastAPI)
Um processo em Python (`worker.py`) fica escutando a fila continuamente.

1.  **Consumo:** O Worker pega a mensagem.
2.  **L√≥gica Idempotente (Delete-then-Insert):**
    *   *Passo 1:* Python chama Qdrant e deleta **todos** os vetores onde `payload.snack_item_id == WLsSS_LBf`. (Isso limpa qualquer "sujeira" anterior).
    *   *Passo 2:* Python usa **LlamaIndex/LangChain** para quebrar o `content_text` em chunks.
    *   *Passo 3:* Python chama a API da **Jina AI (v3)** para gerar embeddings.
    *   *Passo 4:* Python insere os novos vetores no Qdrant.
3.  **Acknowledge (Ack):** Se tudo deu certo, o Python avisa o RabbitMQ: "Mensagem processada, pode apagar".

---

### 4. Tratamento de Falhas (Resili√™ncia)

O que acontece se a API da Jina cair ou o Qdrant estiver indispon√≠vel no momento da sincroniza√ß√£o?

Sem fila, o dado seria perdido e a busca da IA ficaria desatualizada para sempre. Com RabbitMQ, implementamos a **Dead Letter Queue (DLQ)**.

1.  O Worker Python tenta processar.
2.  Ocorre erro (ex: Timeout na Jina).
3.  O Python envia um `Nack` (Negative Acknowledge).
4.  O RabbitMQ espera X segundos e coloca a mensagem de volta na fila (Retry).
5.  Ap√≥s 5 tentativas falhas, a mensagem vai para uma fila especial chamada `dlq.ingestion.errors`.
6.  **Alerta:** Seu time recebe um aviso para investigar, mas **nenhum dado √© perdido**.

---

### 5. Casos Especiais de Sincroniza√ß√£o

#### Atualiza√ß√£o de Metadados (Ex: Mudar o nome da Tabela)
Se o usu√°rio muda o t√≠tulo da tabela de "Vendas 2023" para "Vendas Final", isso afeta o contexto de *todas* as c√©lulas daquela tabela.
*   **Estrat√©gia:** O Go envia um evento `TABLE_METADATA_UPDATED`.
*   **A√ß√£o do Python:** O Qdrant permite atualizar o payload de milhares de vetores atomicamente sem precisar re-gerar o embedding (que √© a parte cara). O Python roda um `Update Payload` em todos os itens com aquele `table_id`.

#### Exclus√£o de Tabela
*   **Evento:** `TABLE_DELETED`.
*   **A√ß√£o:** Python roda um delete no Qdrant filtrando por `table_id`. Simples e r√°pido.

---

### 6. Diagrama de Sequ√™ncia (Resumo T√©cnico)

```mermaid
sequenceDiagram
    participant User as Usu√°rio (Frontend)
    participant Go as Backend Go
    participant Rabbit as RabbitMQ
    participant Py as AI Worker (Python)
    participant Jina as Jina AI API
    participant Qdrant as Vector DB

    User->>Go: Salva C√©lula (Update)
    Go->>Go: Salva no Postgres
    Go->>Rabbit: Publica {ITEM_UPDATED}
    Go-->>User: Retorna 200 OK (Instant√¢neo)
    
    loop Async Process
        Py->>Rabbit: Consome Mensagem
        Py->>Qdrant: Delete vetores antigos (snack_item_id)
        Py->>Py: Chunking do Texto (LlamaIndex)
        Py->>Jina: Gera Embeddings (v3)
        Jina-->>Py: Vetores
        Py->>Qdrant: Upsert (Novos Vetores + Payload)
        Py->>Rabbit: Ack (Sucesso)
    end
```

### 7. Vantagens Competitivas dessa Arquitetura

1.  **Escalabilidade Infinita:** Se 10.000 usu√°rios salvarem tabelas ao mesmo tempo, o Go n√£o trava. A fila enche, e voc√™ pode subir automaticamente mais Workers Python (Auto-scaling) para drenar a fila rapidamente.
2.  **Desacoplamento:** Se voc√™ precisar fazer manuten√ß√£o no m√≥dulo de IA, o site principal continua funcionando perfeitamente. As atualiza√ß√µes apenas ficam "na fila" esperando o sistema voltar.
3.  **Economia:** Voc√™ processa as atualiza√ß√µes de forma controlada, evitando picos de custo de API desnecess√°rios.

Esta √© a pe√ßa que faltava para garantir que a **Snack Prompt** seja n√£o apenas inteligente, mas extremamente confi√°vel e robusta para uso Enterprise.